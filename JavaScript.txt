Резюмируем
JavaScript — это интерпретируемый язык высокого уровня с динамической и слабой типизацией. 

Где и как запускать JavaScript 
Главный обработчик языка — браузер. Поэтому мы можем вести работу, например, в Google Chrome
Альтернатива разработки в браузере — текстовый редактор. Можно использовать Sublime или VScode.
Но для JavaScript больше подойдет рассмотренный WebStorm от компании Jetbrains


Подключение скриптов
Допустим, у вас есть HTML-документ. Подключение скриптов осуществляется с помощью тега <script>

src	Адрес файла, содержащего скрипт, для импорта в текущий документ.

async Логический атрибут. Указывает браузеру загружать скрипт асинхронно. 
Это означает, что указанный в атрибуте src файл будет выполняться без ожидания загрузки и отображения веб-страницы. 

defer Логический атрибут. Указывает браузеру, что следует отложить выполнение скрипта до тех пор, пока HTML-страница не будет загружена полностью.

type Определяет тип содержимого тега. В HTML5 атрибут перестал быть обязательным. По умолчанию равен text/javascript.


  <body>
    <h1>Hello, world!</h1>
    <script type="text/javascript">
      alert("Не пугайтесь! Просто нажмите кнопку ОК");
    </script>
  </body>


  Тут алерт не вызовется, так как есть src
  <script src="javascript.js">
    alert("!!! JavaScript !!!");
  </script>


Вставка JavaScript в HTML из отдельного файла
Чаще всего JavaScript подключают к HTML-странице путём импорта файла. Выглядеть это может вот так:

<!-- HTML4 -->
<script type="text/javascript" src="javascript.js"></script>

<!-- HTML5 -->
<script src="javascript.js"></script>

Браузер скачивает указанный скрипт только в первый раз, а в дальнейшем обычно берёт его из своего кеша. 
Страница при повторной загрузке выглядит более живой.

Как правило, вставкой JavaScript непосредственно в HTML-файл пользуются только для очень небольших скриптов, а сложные выносят в отдельный файл.

Если у нас есть несколько скриптов с атрибутом async, они могут выполняться в любом порядке. То, что первое загрузится, запустится в первую очередь.





-----------!!!JS!!!-------------

prompt() - Даёт JS возможность выводить специальное окно (pop-up), куда пользователь вводит какое-то значение
alert() - Используется для вывода результата обработки или любой другой информации на экран пользователя при помощи специального окна
console.log() - консоль

JavaScript определяет 8 встроенных типов данных:
null - Может принимать только значение null.
undefined - Переменная, которой не было присвоено значение, будет иметь значение undefined
boolean - Имеет два значения true или false.
number - общее для всех чисел, можно получить неточное число
string
symbol
object
bigInt - работать с целыми числами произвольной длины (более 16)

Все эти данные, кроме object, являются «простыми» или «примитивными»

В JavaScript есть так называемые встроенные, или глобальные объекты (built-in object). 
В их число входят объекты, эквивалентные типам данных с их методами и свойствами, например String или Object, и многие другие.

var - объявляет переменную (устаревшее)
let — объявляет локальную переменную в области видимости
const — объявляет именованную константу*. Значение доступно только для чтения

Отличия между let и const в том, что переменная, записанная через let, может быть изменена (будь то объект, или примитив).
Если переменная, записанная через const, примитив — её значение не может быть изменено. 
Если это объект, то свойства объекта могут быть изменены, а сам объект — нет.

Оператор typeof, с помощью которого можно моментально узнать о типе данных:
let a = 10;
typeof a; 
"number"

Инициализация переменной значением является необязательной
Переменные в JavaScript не имеют типа: переменной может быть присвоено значение любого типа 
и позднее этой же переменной может быть присвоено значение другого типа - динамическая типизация
*Константы — это переменные, которые не будут подвержены изменениям. Их принято писать заглавными буквами, разделяя нижним подчёркиванием.

Операторы сравнения
Равно (==) - Возвращает true, если операнды равны. Оператор сначала приводит операнды к одному типу, и затем применяет строгое сравнение.
Строго равно (===) - Возвращает true, если операнды строго равны и имеют одинаковый тип.
Текст сравнивается по количеству символов и совпадению символов на одинаковых местах

Неявное
Возвращают false	
0, -0, NaN, пустая строка в любых кавычках, null, undefined, false

Возвращают true
Все остальные значения, включая отрицательные числа, пустой массив или объект.


Явное преобразование происходит с использованием вызова функции Boolean:
Boolean([123]); 
true

Boolean('');
false

!!!Логические операторы

1. Бинарные логические операторы
|| — возвращает первое значение, которое соответствует true, иначе (когда все false) — последнее значение.
&& — возвращает первое значение, которое соответствует false, иначе (когда все true) — последнее значение

Логический оператор возвращает значение одного и только одного из своих операндов


2. Унарный логический оператор
Его результат — всегда булево значение!
! - отрицание
!! - двоеное отрицание

!true;
false

!0; 
true

!!0; 
falase


!!!Условные операторы

В JS используются три условных оператора:
if-else
switch
тернарный

1 if-else
if (condition)
    statement1
[else
    statement2]


2 switch
switch (result) {
    case (result < 0):
        console.log('результат меньше 0');
        break;
    default:
        console.log('результат больше или равен 0');
}


3 тернарный
Уникальный в своем роде оператор, так как состоит из трёх операндов (отсюда и название).
let result = условие ? значение1 : значение2;
text  = result < 4 ? "результат меньше 4" : "результат больше или равен 4"



!!!String Numbers!!!

Строка — это неизменяемая, упорядоченная последовательность 16-битных значений, каждое из которых обычно представляет символ Юникода. 
Строки являются типом данных, используемым для представления текста.

В языке С# это char. 
В JavaScript есть только тип «строка» — string.

С помощью обратных кавычек:
let firstName= 'Ivan';
let result = `${firstName} glad to see you!`;
ИЛИ
`${str0}${firstNameExp}${str1}${lastNameExp}`

Длина строки
let str= 'Count';
console.log( str.length );

Регистр
let str= 'Count';
console.log( str.toLowerCase() );
console.log( str.toUpperCase() );

Подстроки
substring, substr и slice

let str = "string";
console.log( str.slice(0, 4) ); 
stri

ОСОБОЕННОСТЬ
let str1 = "string";
let str2 = "STRING";
str1 > str2 - так как по ASCII значение строчныз больше чем заглавных


Number — числовой тип данных в формате 64-битного. Их часто называют «числа двойной точности с плавающей точкой*» (стандарт IEEE 754) («double precision»).

ОСОБЕННОСТЬ
0.1 + 0.2 === 0.3;
false, так как дробные числа хранятся в памяти с некоторой погрешностью

0.1 + 0.2 === 0.30000000000000004;
true

Максимальное безопасное целочисленное значение — Number.MAX_VALUE.
Существуют специальные числовые значения Infinity (как плюс, так и минус бесконечность) и NaN (не число)

BigInt — это встроенный объект, который предоставляет способ представлять целые числа больше 2 53 - 1
Он похож на Number, но отличается в некоторых ключевых моментах: 
- его нельзя использовать с математическими методами во встроенном объекте Math
- нельзя смешивать в операциях с любыми экземплярами Number.

Math - для математических действий

const result = Math.log(Math.PI);
console.log(result);



!!!Массивы!!!
Массивы в JavaScript могут состоять из данных различного типа. 
Это значит, что может быть массив, состоящий только из чисел — [1, 2, 3], 
а может быть массив, состоящий из абсолютно всех типов данных в разных комбинациях — [true, 'string', 123, false, null].

В JavaScript массивы являются подмножеством объектов, то есть любой массив — это объект

Как определить что элемент массив:
1. Наличие свойства length

Свойство length — встроенное. Оно возвращает количество элементов массива. 
В большинстве случаев типа object и наличия свойства length достаточно, чтобы считать элемент массивом.

const obj =  {a: 1, b: 2};
console.log(obj.length);
undefined

const arr =  [1, 2];
console.log(arr.length);
2

2. Метод Array.isArray()

const obj =  {a: 1, b: 2};
console.log(Array.isArray(obj)) ;
false

const arr =  [1, 2];
console.log(Array.isArray(arr));
true


!!DEBUGGING
Чтобы произвести дебаг нужно в месте остановки написать слово debugger и перейти в бразуере на влкадку Source


!!Методы работы с массивами
Мутирующие методы изменяют исходный массив, а немутирующие — не изменяют.

Мутирующие методы:
.push(...items), .unshift(...items)	- Добавляют элементы в конец/начало массива.
.pop(), .shift() - Удаляют элемент из конца/начала массива.
.splice(index[, deleteCount, elem1, ..., elemN]) - Удаляет и добавляет элементы.
.concat() - Склеивает массивы.

Немутирующие методы:
.map(cb) - Перебирающий метод массива, принимающий как аргумент функцию cb.
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

let arr = [1,2,3];
let result = arr.map(function(item, index, array) {

  return item + 1

});
console.log(arr);
[1, 2, 3]
console.log(result);
[2, 3, 4]


.reduce(cb) или reduceRight(cb)	- Эти методы используются для вычисления какого-нибудь единого значения на основе всего массива.

let arr = [1, 2, 3];
let result = arr.reduce(function(sum,  item, index, array){

  return sum + item

}, 0);
console.log(result); 
6



!!!Цикл!!!

1. Цикл for
for ([initialization]; [condition]; [incrementExpression]) {

    Statement

}

for (let i = 0; i < 10; i = i + 1) {

    console.log(i)

}

бесконечный цикл:
for (;;) {

    console.log('infinity loop')

}



2. Цикл while

while (condition) {

      Statement
}

let i = 0;
while (i < 10) {
     i = i + 1
     console.log(i)
}

бесконечный цикл:
while (true) {

    console.log('infinity loop')

}


3. Цикл do...while - особенность в том, что он выполнится по крайней мере один раз, даже если условие ложно.

let i = 0;
do {
    i = i + 1
    console.log(i)
} while (i < 10)


4. Кроме этого, существует специальный метод массива:

.forEach(), который является мутирующим методом массива
.map(), который является немутирующим (его мы рассмотрели ранее).

arr.forEach(function(item, index, array) {

  // возвращается новое значение вместо элемента

});


!!!Ассоциативный массив — это массив, у которого в качестве ключей используются строки.

В JavaScript объекты являются ассоциативными массивами. 

let user = {     // объект

  name: "Ivan",  // под ключом "name" хранится значение "Ivan"

  age: 30        // под ключом "age" хранится значение 30

};

Если в такой массив передать любой объект, то он будет приведен к строке, а вот в Map или Set нет

В стандарте ES2015 появились структуры, которые могут стать отличной альтернативой объектам: 
Map, Set, WeakMap и WeakSet.


!!Map
Когда есть необходимость задать имя свойства любого другого типа (отличного от строки, даже объектом), 
можно использовать структуру Map; она позволяет использовать ключи любого типа

let map = new Map();

map.set("1", "string");  
// строка в качестве ключа

map.set(1, "number"); 
// цифра как ключ

map.set(true, "boolean");
// булевое значение как ключ

console.log(map.get(1));
number
console.log(map.get("1"));
string

________
let fruits = new Map([

  ["apple", "green"],

  ["strawberry", "red"],

  ["blueberry",    "blue"]

]);

Для перебора по ключам — названию фрукта, используем метод .keys()
for (let name of fruits.keys()) {

  console.log(name); // apple, strawberry, blueberry

}

Для перебора по значениям — цвету фрукта, используем метод .values()
for (let color of fruits.values()) {

  console.log(color); // green, red, blue

}

Для перебора по элементам в формате [ключ, значение] 
for (let elem of fruits) { // то же самое, что и fruits.entries()

   console.log(elem); // apple, green, strawberry, red, blueberry, blue

}

!!Set
Это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз. 
То есть, в таком объекте могут храниться только уникальные значения.





!!!Функции!!!

Функция — это блок программного кода, который определяется один раз и может выполняться (вызываться) многократно.

Функция в JavaScript — это объект, который может быть вызван как подпрограмма.
Все функции в JavaScript — это объекты!

function funcName() {

  const str = 'My first function';

  console.log(str);

}



Классическое объявление функции называется Function Declaration (FD).

Пример:

function sum() {

  const result = 1 + 2;

  console.log(result);

};


Другой подход к объявлению функций — Function Expression (FE).

Пример:

const sum = function() {

  const result = 1 + 2;

  console.log(result);

};


Отличия:
Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода, 
поэтому их можно вызвать до объявления.

Функции, объявленные как FE, ведут себя по-разному в зависимости от того, какой оператор был использован. 
Функции, объявленные как FD, всегда ведут себя одинаково.

Если используешь все-таки используешь FE, то лучше делать через const (так как ты один раз скорее объявишь и не будешь перезаписывать)



!!Аргументы функции

function sum(a, b) {

  const result = a + b;

  console.log(result);

};

sum(1,2); - все ок, будет = 3

sum(); // не передаём аргументы - undefined + undefined = NaN

sum(1); // передаём меньше заданного количества параметров - undefined + 1 = NaN

sum(1,2,3); // передаём больше заданного количества параметров - сложит нужнын по порядку, остальные отбросит


sum.length - Это число называется арность (arity) — количество параметров у функции.

Для доступа к аргументам может также использоваться псевдомассив - arguments - используют тогда, когда задано больше аргументов, чем параметров

обращение к аргументам:
function log(a, b, c) {

  console.log(arguments); или console.log(arguments[2]);

}

задание дефолтного значения:
function log(a = 0) {

  console.log(a);

}


И процедура, и функция — набор инструкций (подпрограмма), который может быть выполнен в определенном порядке. 
Отличие заключается в том, что функция всегда должна возвращать значение 
(более строгое определение требует также, чтобы у функции всегда были входные данные).


Для явного указания значения, которое должно вернуться из функции, используется инструкция return. 
Если выражение после ключевого слова return не указано, то функция возвращает undefined.

const sum = function(a, b) {

  return a + b;

  console.log(100); // не вызовется никогда

};


!!!Функциональное программирование - на основании функций

Особенностью функционального подхода является его декларативность — когда мы описываем конечный результат, а не полный алгоритм действия.

First-class citizen or object — функции высшего порядка (или функции первого класса, или объекты первого класса). - это
Функции, которые могут принимать другие функции как аргумент и возвращать функции как значение.

В JavaScript все функции являются объектами первого класса — они могут быть переданы как аргумент, возвращены из функции и присвоены переменной


function example(func){

  // вызываем функцию, которую приняли как аргумент
  func();

 // возвращаем функцию
  return function(){

    console.log('internal function')

  }

}


// функция, которую будем передавать как аргумент в функцию example
function argFunc(){

  console.log('function from arguments')

}

// в переменную resultFunc записываем результат выполнения функции example
// функция, которая передаётся как аргумент, должна быть без круглых скобок
const resultFunc = example(argFunc);

// после вызова example() внутри неё будет вызвана функция argFunc, которую мы передали как аргумент, и в консоли будет текст: function from arguments
// вызываем функцию
resultFunc(); // 'internal function


!!!Область видимости
Если var то ограничивается только скобками функции, а не if или еще чем-то
лучше использовать let и const - там как в c#

!!!Замыкания - это комбинация функции и всех лексически сохранённых родительских областей видимости. 
При этом, посредством этих сохраненных объектов областей видимости, функция может использовать свободные переменные.

При создании функция получает скрытое свойство [[Environment]], которое ссылается на область видимости, 
в которой она была создана. 
При вызове функции, куда бы её ни передали в коде, она будет искать переменные сначала у себя, а затем во внешних областях видимости, 
которые берутся из [[Environment]].

const a = 10;

const func = function() {

  console.log(a);

};

func();
Вывод: 10

const func2 = function() {
  
  const a = 20;
  func();

};

func2();
Вывод все равно: 10



!!!Анонимные функции
Если после ключевого слова function есть имя, то функция именованная, иначе — анонимная.

1 Анономная функция (функц. выражение):
const sum = function() {

  const result = a + b;

  console.log(result);

};

2 Именованным функциональным выражением: - используется только для рекурсии
const sum = function summa() {

  const result = a + b;

  console.log(result);

};

Рекурсия:
const fibo = function fibonacci() {
  
   fibonacci(); // функция вызывает сама себя

};

3 IIFE — Immediately Invoked Function Expression — «немедленно вызывающееся функциональное выражение», но обычно говорят «самовызывающиеся функции».

(function() {
  
  alert("Example 1!");

}());

(function() {

  alert("Example 2");

})();


!!!Callbacks - или функция обратного вызова — функция, которая выполняется в конце операции, когда все остальные операции уже завершены

Как правило, функция обратного вызова передаётся в качестве последнего аргумента функции. 
Часто функцию обратного вызова определяют как анонимную функцию.

Области использования:

1 Когда необходимо выполнить какой-то код по завершении асинхронного действия 
(загрузка информации из базы данных, например).

function loadData(url, cb) {
let result = doSomethingAndGetResult(url)

// onload сработает тогда, когда result полностью прогрузится и колбэк будет вызван
result.onload = function () {
    cb();
}

}


loadData('url', function(){
	вызов колбэка
})


2 Как аргумент во многих методах массива

const arr = [1, 2, 3]

arr.forEach(function(item){

    console.log(item+1)

})

3 Как аргумент в методах setTimeout, setInterval и других

Методы setTimeout, setInterval

!!!setTimeout(func|code, [delay], [arg1], [arg2], ...)

func|code — колбэк или кусок кода,
delay — задержка в милисекундах
ar1...argN - аргументы, которые передаются в колбэк

Пример 1:
function sum(a, b) {

  console.log(a + b);

}

setTimeout(sum, 1000, 1, 2); // задержка 1 секунда

Пример 2:
setTimeout(function (a, b) {

   console.log(a + b);

}, 1000, 1, 2); // задержка 1 секунда


Вызов функции setTimeout вернёт timerId, который можно записать в переменную и затем очистить. 
Но это не является обязательным условием — его можно использовать, если вы запустили таймер, а потом передумали.

const timerId = setTimeout(function (a, b) {

   console.log(a + b);

}, 1000, 1, 2);

clearTimeout(timerId)


!!!setInterval - абсолютно такой же синтаксис, как и setTimeout

Вызов setInterval вернёт идентификатор, который можно очистить, если вы передумали выполнять регулярное действие

Пример 1:
// Каждую секунду в консоль будет падать сумма чисел a и b.
const intervalId = setInterval(function (a, b) {

   console.log(a + b);

}, 1000, 1,  2); 

clearInterval(intervalId)



!!!Arrow Function

Обычная запись:
function sayMyName (name) {
 console.log('My name is ' + name);
}

const sayMyName = name => {
console.log('My name is ' + name);
}


const logText = text => console.log(text);
const sayHelloWorld = () => console.log('Hello, world!');
const sum = (a, b) => a + b;

Особенности:
Короткий синтаксис.
Отсутствие привязки к this
Нельзя использовать как конструктор
Нет псевдомассива arguments.