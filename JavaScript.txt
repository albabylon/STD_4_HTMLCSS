Резюмируем
JavaScript — это интерпретируемый язык высокого уровня с динамической и слабой типизацией. 

Где и как запускать JavaScript 
Главный обработчик языка — браузер. Поэтому мы можем вести работу, например, в Google Chrome
Альтернатива разработки в браузере — текстовый редактор. Можно использовать Sublime или VScode.
Но для JavaScript больше подойдет рассмотренный WebStorm от компании Jetbrains


Подключение скриптов
Допустим, у вас есть HTML-документ. Подключение скриптов осуществляется с помощью тега <script>

src	Адрес файла, содержащего скрипт, для импорта в текущий документ.

async Логический атрибут. Указывает браузеру загружать скрипт асинхронно. 
Это означает, что указанный в атрибуте src файл будет выполняться без ожидания загрузки и отображения веб-страницы. 

defer Логический атрибут. Указывает браузеру, что следует отложить выполнение скрипта до тех пор, пока HTML-страница не будет загружена полностью.

type Определяет тип содержимого тега. В HTML5 атрибут перестал быть обязательным. По умолчанию равен text/javascript.


  <body>
    <h1>Hello, world!</h1>
    <script type="text/javascript">
      alert("Не пугайтесь! Просто нажмите кнопку ОК");
    </script>
  </body>


  Тут алерт не вызовется, так как есть src
  <script src="javascript.js">
    alert("!!! JavaScript !!!");
  </script>


Вставка JavaScript в HTML из отдельного файла
Чаще всего JavaScript подключают к HTML-странице путём импорта файла. Выглядеть это может вот так:

<!-- HTML4 -->
<script type="text/javascript" src="javascript.js"></script>

<!-- HTML5 -->
<script src="javascript.js"></script>

Браузер скачивает указанный скрипт только в первый раз, а в дальнейшем обычно берёт его из своего кеша. 
Страница при повторной загрузке выглядит более живой.

Как правило, вставкой JavaScript непосредственно в HTML-файл пользуются только для очень небольших скриптов, а сложные выносят в отдельный файл.

Если у нас есть несколько скриптов с атрибутом async, они могут выполняться в любом порядке. То, что первое загрузится, запустится в первую очередь.





-----------!!!JS!!!-------------

prompt() - Даёт JS возможность выводить специальное окно (pop-up), куда пользователь вводит какое-то значение
alert() - Используется для вывода результата обработки или любой другой информации на экран пользователя при помощи специального окна
console.log() - консоль

JavaScript определяет 8 встроенных типов данных:
null - Может принимать только значение null.
undefined - Переменная, которой не было присвоено значение, будет иметь значение undefined
boolean - Имеет два значения true или false.
number - общее для всех чисел, можно получить неточное число
string
symbol
object
bigInt - работать с целыми числами произвольной длины (более 16)

Все эти данные, кроме object, являются «простыми» или «примитивными»

В JavaScript есть так называемые встроенные, или глобальные объекты (built-in object). 
В их число входят объекты, эквивалентные типам данных с их методами и свойствами, например String или Object, и многие другие.

var - объявляет переменную (устаревшее)
let — объявляет локальную переменную в области видимости
const — объявляет именованную константу*. Значение доступно только для чтения

Отличия между let и const в том, что переменная, записанная через let, может быть изменена (будь то объект, или примитив).
Если переменная, записанная через const, примитив — её значение не может быть изменено. 
Если это объект, то свойства объекта могут быть изменены, а сам объект — нет.

Оператор typeof, с помощью которого можно моментально узнать о типе данных:
let a = 10;
typeof a; 
"number"

Инициализация переменной значением является необязательной
Переменные в JavaScript не имеют типа: переменной может быть присвоено значение любого типа 
и позднее этой же переменной может быть присвоено значение другого типа - динамическая типизация
*Константы — это переменные, которые не будут подвержены изменениям. Их принято писать заглавными буквами, разделяя нижним подчёркиванием.

Операторы сравнения
Равно (==) - Возвращает true, если операнды равны. Оператор сначала приводит операнды к одному типу, и затем применяет строгое сравнение.
Строго равно (===) - Возвращает true, если операнды строго равны и имеют одинаковый тип.
Текст сравнивается по количеству символов и совпадению символов на одинаковых местах

Неявное
Возвращают false	
0, -0, NaN, пустая строка в любых кавычках, null, undefined, false

Возвращают true
Все остальные значения, включая отрицательные числа, пустой массив или объект.


Явное преобразование происходит с использованием вызова функции Boolean:
Boolean([123]); 
true

Boolean('');
false

!!!Логические операторы

1. Бинарные логические операторы
|| — возвращает первое значение, которое соответствует true, иначе (когда все false) — последнее значение.
&& — возвращает первое значение, которое соответствует false, иначе (когда все true) — последнее значение

Логический оператор возвращает значение одного и только одного из своих операндов


2. Унарный логический оператор
Его результат — всегда булево значение!
! - отрицание
!! - двоеное отрицание

!true;
false

!0; 
true

!!0; 
falase


!!!Условные операторы

В JS используются три условных оператора:
if-else
switch
тернарный

1 if-else
if (condition)
    statement1
[else
    statement2]


2 switch
switch (result) {
    case (result < 0):
        console.log('результат меньше 0');
        break;
    default:
        console.log('результат больше или равен 0');
}


3 тернарный
Уникальный в своем роде оператор, так как состоит из трёх операндов (отсюда и название).
let result = условие ? значение1 : значение2;
text  = result < 4 ? "результат меньше 4" : "результат больше или равен 4"



!!!String Numbers!!!

Строка — это неизменяемая, упорядоченная последовательность 16-битных значений, каждое из которых обычно представляет символ Юникода. 
Строки являются типом данных, используемым для представления текста.

В языке С# это char. 
В JavaScript есть только тип «строка» — string.

С помощью обратных кавычек:
let firstName= 'Ivan';
let result = `${firstName} glad to see you!`;
ИЛИ
`${str0}${firstNameExp}${str1}${lastNameExp}`

Длина строки
let str= 'Count';
console.log( str.length );

Регистр
let str= 'Count';
console.log( str.toLowerCase() );
console.log( str.toUpperCase() );

Подстроки
substring, substr и slice

let str = "string";
console.log( str.slice(0, 4) ); 
stri

ОСОБОЕННОСТЬ
let str1 = "string";
let str2 = "STRING";
str1 > str2 - так как по ASCII значение строчныз больше чем заглавных


Number — числовой тип данных в формате 64-битного. Их часто называют «числа двойной точности с плавающей точкой*» (стандарт IEEE 754) («double precision»).

ОСОБЕННОСТЬ
0.1 + 0.2 === 0.3;
false, так как дробные числа хранятся в памяти с некоторой погрешностью

0.1 + 0.2 === 0.30000000000000004;
true

Максимальное безопасное целочисленное значение — Number.MAX_VALUE.
Существуют специальные числовые значения Infinity (как плюс, так и минус бесконечность) и NaN (не число)

BigInt — это встроенный объект, который предоставляет способ представлять целые числа больше 2 53 - 1
Он похож на Number, но отличается в некоторых ключевых моментах: 
- его нельзя использовать с математическими методами во встроенном объекте Math
- нельзя смешивать в операциях с любыми экземплярами Number.

Math - для математических действий

const result = Math.log(Math.PI);
console.log(result);



!!!Массивы!!!
Массивы в JavaScript могут состоять из данных различного типа. 
Это значит, что может быть массив, состоящий только из чисел — [1, 2, 3], 
а может быть массив, состоящий из абсолютно всех типов данных в разных комбинациях — [true, 'string', 123, false, null].

В JavaScript массивы являются подмножеством объектов, то есть любой массив — это объект

Как определить что элемент массив:
1. Наличие свойства length

Свойство length — встроенное. Оно возвращает количество элементов массива. 
В большинстве случаев типа object и наличия свойства length достаточно, чтобы считать элемент массивом.

const obj =  {a: 1, b: 2};
console.log(obj.length);
undefined

const arr =  [1, 2];
console.log(arr.length);
2

2. Метод Array.isArray()

const obj =  {a: 1, b: 2};
console.log(Array.isArray(obj)) ;
false

const arr =  [1, 2];
console.log(Array.isArray(arr));
true


!!DEBUGGING
Чтобы произвести дебаг нужно в месте остановки написать слово debugger и перейти в бразуере на влкадку Source


!!Методы работы с массивами
Мутирующие методы изменяют исходный массив, а немутирующие — не изменяют.

Мутирующие методы:
.push(...items), .unshift(...items)	- Добавляют элементы в конец/начало массива.
.pop(), .shift() - Удаляют элемент из конца/начала массива.
.splice(index[, deleteCount, elem1, ..., elemN]) - Удаляет и добавляет элементы.
.concat() - Склеивает массивы.

Немутирующие методы:
.map(cb) - Перебирающий метод массива, принимающий как аргумент функцию cb.
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

let arr = [1,2,3];
let result = arr.map(function(item, index, array) {

  return item + 1

});
console.log(arr);
[1, 2, 3]
console.log(result);
[2, 3, 4]


.reduce(cb) или reduceRight(cb)	- Эти методы используются для вычисления какого-нибудь единого значения на основе всего массива.

let arr = [1, 2, 3];
let result = arr.reduce(function(sum,  item, index, array){

  return sum + item

}, 0);
console.log(result); 
6



!!!Цикл!!!

1. Цикл for
for ([initialization]; [condition]; [incrementExpression]) {

    Statement

}

for (let i = 0; i < 10; i = i + 1) {

    console.log(i)

}

бесконечный цикл:
for (;;) {

    console.log('infinity loop')

}



2. Цикл while

while (condition) {

      Statement
}

let i = 0;
while (i < 10) {
     i = i + 1
     console.log(i)
}

бесконечный цикл:
while (true) {

    console.log('infinity loop')

}


3. Цикл do...while - особенность в том, что он выполнится по крайней мере один раз, даже если условие ложно.

let i = 0;
do {
    i = i + 1
    console.log(i)
} while (i < 10)


4. Кроме этого, существует специальный метод массива:

.forEach(), который является мутирующим методом массива
.map(), который является немутирующим (его мы рассмотрели ранее).

arr.forEach(function(item, index, array) {

  // возвращается новое значение вместо элемента

});


!!!Ассоциативный массив — это массив, у которого в качестве ключей используются строки.

В JavaScript объекты являются ассоциативными массивами. 

let user = {     // объект

  name: "Ivan",  // под ключом "name" хранится значение "Ivan"

  age: 30        // под ключом "age" хранится значение 30

};

Если в такой массив передать любой объект, то он будет приведен к строке, а вот в Map или Set нет

В стандарте ES2015 появились структуры, которые могут стать отличной альтернативой объектам: 
Map, Set, WeakMap и WeakSet.


!!Map
Когда есть необходимость задать имя свойства любого другого типа (отличного от строки, даже объектом), 
можно использовать структуру Map; она позволяет использовать ключи любого типа

let map = new Map();

map.set("1", "string");  
// строка в качестве ключа

map.set(1, "number"); 
// цифра как ключ

map.set(true, "boolean");
// булевое значение как ключ

console.log(map.get(1));
number
console.log(map.get("1"));
string

________
let fruits = new Map([

  ["apple", "green"],

  ["strawberry", "red"],

  ["blueberry",    "blue"]

]);

Для перебора по ключам — названию фрукта, используем метод .keys()
for (let name of fruits.keys()) {

  console.log(name); // apple, strawberry, blueberry

}

Для перебора по значениям — цвету фрукта, используем метод .values()
for (let color of fruits.values()) {

  console.log(color); // green, red, blue

}

Для перебора по элементам в формате [ключ, значение] 
for (let elem of fruits) { // то же самое, что и fruits.entries()

   console.log(elem); // apple, green, strawberry, red, blueberry, blue

}

!!Set
Это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз. 
То есть, в таком объекте могут храниться только уникальные значения.
