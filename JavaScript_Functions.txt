!!!Функции!!!

Функция — это блок программного кода, который определяется один раз и может выполняться (вызываться) многократно.

Функция в JavaScript — это объект, который может быть вызван как подпрограмма.
Все функции в JavaScript — это объекты!

function funcName() {

  const str = 'My first function';

  console.log(str);

}



Классическое объявление функции называется Function Declaration (FD).

Пример:

function sum() {

  const result = 1 + 2;

  console.log(result);

};


Другой подход к объявлению функций — Function Expression (FE).

Пример:

const sum = function() {

  const result = 1 + 2;

  console.log(result);

};


Отличия:
Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода, 
поэтому их можно вызвать до объявления.

Функции, объявленные как FE, ведут себя по-разному в зависимости от того, какой оператор был использован. 
Функции, объявленные как FD, всегда ведут себя одинаково.

Если используешь все-таки используешь FE, то лучше делать через const (так как ты один раз скорее объявишь и не будешь перезаписывать)



!!Аргументы функции

function sum(a, b) {

  const result = a + b;

  console.log(result);

};

sum(1,2); - все ок, будет = 3

sum(); // не передаём аргументы - undefined + undefined = NaN

sum(1); // передаём меньше заданного количества параметров - undefined + 1 = NaN

sum(1,2,3); // передаём больше заданного количества параметров - сложит нужнын по порядку, остальные отбросит


sum.length - Это число называется арность (arity) — количество параметров у функции.

Для доступа к аргументам может также использоваться псевдомассив - arguments - используют тогда, когда задано больше аргументов, чем параметров

обращение к аргументам:
function log(a, b, c) {

  console.log(arguments); или console.log(arguments[2]);

}

задание дефолтного значения:
function log(a = 0) {

  console.log(a);

}


И процедура, и функция — набор инструкций (подпрограмма), который может быть выполнен в определенном порядке. 
Отличие заключается в том, что функция всегда должна возвращать значение 
(более строгое определение требует также, чтобы у функции всегда были входные данные).


Для явного указания значения, которое должно вернуться из функции, используется инструкция return. 
Если выражение после ключевого слова return не указано, то функция возвращает undefined.

const sum = function(a, b) {

  return a + b;

  console.log(100); // не вызовется никогда

};


!!!Функциональное программирование - на основании функций

Особенностью функционального подхода является его декларативность — когда мы описываем конечный результат, а не полный алгоритм действия.

First-class citizen or object — функции высшего порядка (или функции первого класса, или объекты первого класса). - это
Функции, которые могут принимать другие функции как аргумент и возвращать функции как значение.

В JavaScript все функции являются объектами первого класса — они могут быть переданы как аргумент, возвращены из функции и присвоены переменной


function example(func){

  // вызываем функцию, которую приняли как аргумент
  func();

 // возвращаем функцию
  return function(){

    console.log('internal function')

  }

}


// функция, которую будем передавать как аргумент в функцию example
function argFunc(){

  console.log('function from arguments')

}

// в переменную resultFunc записываем результат выполнения функции example
// функция, которая передаётся как аргумент, должна быть без круглых скобок
const resultFunc = example(argFunc);

// после вызова example() внутри неё будет вызвана функция argFunc, которую мы передали как аргумент, и в консоли будет текст: function from arguments
// вызываем функцию
resultFunc(); // 'internal function


!!!Область видимости
Если var то ограничивается только скобками функции, а не if или еще чем-то
лучше использовать let и const - там как в c#

!!!Замыкания - это комбинация функции и всех лексически сохранённых родительских областей видимости. 
При этом, посредством этих сохраненных объектов областей видимости, функция может использовать свободные переменные.

При создании функция получает скрытое свойство [[Environment]], которое ссылается на область видимости, 
в которой она была создана. 
При вызове функции, куда бы её ни передали в коде, она будет искать переменные сначала у себя, а затем во внешних областях видимости, 
которые берутся из [[Environment]].

const a = 10;

const func = function() {

  console.log(a);

};

func();
Вывод: 10

const func2 = function() {
  
  const a = 20;
  func();

};

func2();
Вывод все равно: 10



!!!Анонимные функции
Если после ключевого слова function есть имя, то функция именованная, иначе — анонимная.

1 Анономная функция (функц. выражение):
const sum = function() {

  const result = a + b;

  console.log(result);

};

2 Именованным функциональным выражением: - используется только для рекурсии
const sum = function summa() {

  const result = a + b;

  console.log(result);

};

Рекурсия:
const fibo = function fibonacci() {
  
   fibonacci(); // функция вызывает сама себя

};

3 IIFE — Immediately Invoked Function Expression — «немедленно вызывающееся функциональное выражение», но обычно говорят «самовызывающиеся функции».

(function() {
  
  alert("Example 1!");

}());

(function() {

  alert("Example 2");

})();


!!!Callbacks - или функция обратного вызова — функция, которая выполняется в конце операции, когда все остальные операции уже завершены

Как правило, функция обратного вызова передаётся в качестве последнего аргумента функции. 
Часто функцию обратного вызова определяют как анонимную функцию.

Области использования:

1 Когда необходимо выполнить какой-то код по завершении асинхронного действия 
(загрузка информации из базы данных, например).

function loadData(url, cb) {
let result = doSomethingAndGetResult(url)

// onload сработает тогда, когда result полностью прогрузится и колбэк будет вызван
result.onload = function () {
    cb();
}

}


loadData('url', function(){
	вызов колбэка
})


2 Как аргумент во многих методах массива

const arr = [1, 2, 3]

arr.forEach(function(item){

    console.log(item+1)

})

3 Как аргумент в методах setTimeout, setInterval и других

Методы setTimeout, setInterval

!!!setTimeout(func|code, [delay], [arg1], [arg2], ...)

func|code — колбэк или кусок кода,
delay — задержка в милисекундах
ar1...argN - аргументы, которые передаются в колбэк

Пример 1:
function sum(a, b) {

  console.log(a + b);

}

setTimeout(sum, 1000, 1, 2); // задержка 1 секунда

Пример 2:
setTimeout(function (a, b) {

   console.log(a + b);

}, 1000, 1, 2); // задержка 1 секунда


Вызов функции setTimeout вернёт timerId, который можно записать в переменную и затем очистить. 
Но это не является обязательным условием — его можно использовать, если вы запустили таймер, а потом передумали.

const timerId = setTimeout(function (a, b) {

   console.log(a + b);

}, 1000, 1, 2);

clearTimeout(timerId)


!!!setInterval - абсолютно такой же синтаксис, как и setTimeout

Вызов setInterval вернёт идентификатор, который можно очистить, если вы передумали выполнять регулярное действие

Пример 1:
// Каждую секунду в консоль будет падать сумма чисел a и b.
const intervalId = setInterval(function (a, b) {

   console.log(a + b);

}, 1000, 1,  2); 

clearInterval(intervalId)



!!!Arrow Function

Обычная запись:
function sayMyName (name) {
 console.log('My name is ' + name);
}

const sayMyName = name => {
console.log('My name is ' + name);
}


const logText = text => console.log(text);
const sayHelloWorld = () => console.log('Hello, world!');
const sum = (a, b) => a + b;

Особенности:
Короткий синтаксис.
Отсутствие привязки к this
Нельзя использовать как конструктор
Нет псевдомассива arguments.