!!!Массивы!!!
Массивы в JavaScript могут состоять из данных различного типа. 
Это значит, что может быть массив, состоящий только из чисел — [1, 2, 3], 
а может быть массив, состоящий из абсолютно всех типов данных в разных комбинациях — [true, 'string', 123, false, null].

В JavaScript массивы являются подмножеством объектов, то есть любой массив — это объект

Как определить что элемент массив:
1. Наличие свойства length

Свойство length — встроенное. Оно возвращает количество элементов массива. 
В большинстве случаев типа object и наличия свойства length достаточно, чтобы считать элемент массивом.

const obj =  {a: 1, b: 2};
console.log(obj.length);
undefined

const arr =  [1, 2];
console.log(arr.length);
2

2. Метод Array.isArray()

const obj =  {a: 1, b: 2};
console.log(Array.isArray(obj)) ;
false

const arr =  [1, 2];
console.log(Array.isArray(arr));
true


!!DEBUGGING
Чтобы произвести дебаг нужно в месте остановки написать слово debugger и перейти в бразуере на влкадку Source


!!Методы работы с массивами
Мутирующие методы изменяют исходный массив, а немутирующие — не изменяют.

Мутирующие методы:
.push(...items), .unshift(...items)	- Добавляют элементы в конец/начало массива.
.pop(), .shift() - Удаляют элемент из конца/начала массива.
.splice(index[, deleteCount, elem1, ..., elemN]) - Удаляет и добавляет элементы.
.concat() - Склеивает массивы.

Немутирующие методы:
.map(cb) - Перебирающий метод массива, принимающий как аргумент функцию cb.
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

let arr = [1,2,3];
let result = arr.map(function(item, index, array) {

  return item + 1

});
console.log(arr);
[1, 2, 3]
console.log(result);
[2, 3, 4]


.reduce(cb) или reduceRight(cb)	- Эти методы используются для вычисления какого-нибудь единого значения на основе всего массива.

let arr = [1, 2, 3];
let result = arr.reduce(function(sum,  item, index, array){

  return sum + item

}, 0);
console.log(result); 
6




!!!Ассоциативный массив — это массив, у которого в качестве ключей используются строки.

В JavaScript объекты являются ассоциативными массивами. 

let user = {     // объект

  name: "Ivan",  // под ключом "name" хранится значение "Ivan"

  age: 30        // под ключом "age" хранится значение 30

};

Если в такой массив передать любой объект, то он будет приведен к строке, а вот в Map или Set нет

В стандарте ES2015 появились структуры, которые могут стать отличной альтернативой объектам: 
Map, Set, WeakMap и WeakSet.


!!Map
Когда есть необходимость задать имя свойства любого другого типа (отличного от строки, даже объектом), 
можно использовать структуру Map; она позволяет использовать ключи любого типа

let map = new Map();

map.set("1", "string");  
// строка в качестве ключа

map.set(1, "number"); 
// цифра как ключ

map.set(true, "boolean");
// булевое значение как ключ

console.log(map.get(1));
number
console.log(map.get("1"));
string

________
let fruits = new Map([

  ["apple", "green"],

  ["strawberry", "red"],

  ["blueberry",    "blue"]

]);

Для перебора по ключам — названию фрукта, используем метод .keys()
for (let name of fruits.keys()) {

  console.log(name); // apple, strawberry, blueberry

}

Для перебора по значениям — цвету фрукта, используем метод .values()
for (let color of fruits.values()) {

  console.log(color); // green, red, blue

}

Для перебора по элементам в формате [ключ, значение] 
for (let elem of fruits) { // то же самое, что и fruits.entries()

   console.log(elem); // apple, green, strawberry, red, blueberry, blue

}

!!Set
Это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз. 
То есть, в таком объекте могут храниться только уникальные значения.