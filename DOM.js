//Навигация и классификация узлов

//Узлы делятся на дочерние и родительские

//ParentNodes
//parentNode - для всех узлов
//parentElement - только для узлов-элементов

//ChildNodes
//childNodes(дочерние узлы) — элементы, которые лежат непосредственно внутри того элемента, к которому обращаются (неглубокая вложенность)
//children(потомки) — все элементы, которые лежат внутри тега, включая вложенные в другие теги: body, div, ul, li, b для HTML.

//childNode, firstChild, lastChild - для всех узлов
//children, firstElementChild, lastElementChild - только для узлов-элементов


//Обратиться к родительскому свойству можно через parentElement или parentNode.
//Они оба возвращают родителя.Но есть небольшой нюанс:
//parentElement вернёт узел-элемент,
//parentNode — любого родителя.

document.documentElement.parentNode === document
document.documentElement.parentElement === null


//Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему дочернему элементу из списка childNodes.
elem.hasChildNodes() //проверить, существуют ли вообще дочерние узлы


//Siblings (соседи) — узлы, у которых один и тот же родитель.
//Правый (следующий) узел — nextSibling.
//Левый(предыдущий) узел — previousSibling.
//Родитель — parentNode
//previousSibling, nextSibling - для всех узлов:
//previousElementSibling, nextElementSibling - только для узлов-элементов:


//1 Поиск элемента в DOM
document.getElementById(id)
document.getElementsByTagName(tagName)
document.getElementsByClassName(className)
document.querySelector(selector) //По любому CSS-селектору (. — класс, # — id, отсутствие — имя тега
document.querySelectorAll(selector) //По любому CSS-селектору (. — класс, # — id, отсутствие — имя тега

//2 Изменение элементов в DOM
elem.innerHTML = "content" //Вставка любого контента напрямую
//Прежде чем вставлять контент, необходимо найти элемент, используя специальные функции, например так: document.getElementById(id)

elem.setAttribute(attr, value) //Вставка/изменение атрибута
//Принимает название атрибута как строку и значение для этого атрибута тоже как строку

elem.style.property = "style" //Добавление стиля
elem.style = "font-size: 20px; color: red"
elem.style.color = "red";

//3 Добавление и удаление элементов в DOM

//Добавление элемента
document.createElement(elem) 

const customDiv = document.createElement("div"); //Создаём элемент
customDiv.innerHTML = "<span id="custom">Привет!</span>"; //Заполняем его (альтернатива document.createElement(elem))
const parent = document.getElementById("id"); //Ищем родительский элемент
document.body.insertBefore(customDiv, parent); //Добавляем созданный элемент в дерево DOM (добавляем до)

//или через шаблонную строку
const content = "Привет!"
const parent = document.getElementById("id");
parent.innerHTML = `<div><span id="custom">${content}</span></div>`;

insertAdjacentHTML() //разбирает указанный текст как HTML или XML и вставляет полученные узлы(nodes) в DOM - дерево в указанную позицию.
//Данная функция не переписывает имеющиеся элементы.
//Принимает как аргументы строки — position и контент
//'beforebegin': до самого element(до открывающего тега);
//'afterbegin': сразу после открывающего тега element(перед первым потомком);
//'beforeend': сразу перед закрывающим тегом element(после последнего потомка);
//'afterend': после element(после закрывающего тега).

const parent = document.getElementById("id");
parent.insertAdjacentHTML('afterend', `<div><span id="custom"> ${content}</span></div>`);

//Удаление элемента
elem.removeChild(child)

const removed = document.getElementById("custom");
const div = document.querySelector("div");
div.removeChild(removed);




//_____________________________________________________________________

//Событие (event) — сигнал от браузера о том, что что-то произошло

//DOMContentLoaded — построено DOM-дерево, но скрипты/стили/контент ещё не подгружены.
//Срабатывает на объекте document, отлавливается с помощью addEventListener.
//Можно искать DOM - узлы и инициализировать интерфейс.

//load — полностью загруженная HTML - страница. Обработать можно, обратившись к свойству window.onload.
//Можно отскроллить страницу до нужного места(пример: онлайн - банки, таблицы), рассчитать размеры элементов.

//beforeunload — пользователь хочет покинуть страницу window.beforeunload
//Можно спросить, действительно ли пользователь хочет уйти.

//unload — пользователь почти покинул страницу window.unload
//Можно отправить метрики или статистику для анализа страницы.

//Когда необходимо среагировать на событие, мы назначаем обработчик.
//Есть несколько способов назначить обработчики:


//1 Используя атрибут или DOM свойство

//А) внутри
//<button onclick="alert('Clicked!')">Press</button>

//Б) в скрипте
//<script>
//  function clickMe() {

//    alert('Clicked!')

//  }
//</script>
//<button onclick="clickMe()">Press</button>

//В) обработчик назначается посредством использования DOM - свойства элемента. Поиск элемента в таком случае происходит по id.
//<button onclick="alert(" HTML clicked")" id = "btn" > Press</button >
//    <script>
//        btn.onclick = function() { // перезапишет существующий обработчик
//            alert('JS clicked'); // выведется это
//  };
//    </script>


//2 Через JavaScript, используя addEventListener.

element.addEventListener(event, handler, [phase]);
//event — имя события, для которого мы хотим зарегистрировать этот обработчик;
//handler — код, содержащий функцию обработчика, которую мы хотим запустить в ответ;
//phase — фаза(обычно не используется, по умолчанию = false);
//phase true — событие будет перехвачено по дороге вниз;
//phase false — событие будет поймано при всплытии.

//<button id="btn">Press</button>

//<script>
//  function click1() {
//    alert('Click1');
//  };

//  function click2() {
//    alert('Click2');
//  }

//  btn.onclick = () => alert("The native handler");
//  btn.addEventListener("click", click1); // Click1
//  btn.addEventListener("click", click2); // Click2
//</script>


//_____________________________________________________________________
//Объект события
//Функция handler метода addEventListener может принимать как аргумент некий event, который называют объектом события.
//Его не нужно создавать самостоятельно — когда происходит событие, браузер создает этот объект события и записывает в него детали
//и передает в обработчик как аргумент. Его принято называть event или просто e

//Часто при разработке приходится обращаться к следующим полям:
//event.type — имя события(“click”);
//event.currentTarget — элемент, на котором обрабатывается событие(для которого событие задано);
//event.target — элемент-триггер, запустивший событие.

//Другие свойства объекта event:
//eventPhase — число, показывающее на каком этапе произошло событие(1 - этапе погружения(перехвата), 2 - на цели, 3 - на этапе всплытия);
//timestamp — число(дата), когда произошло событие;
//bubbles — возвращает логическое значение, указывающее может ли данное событие всплывать;
//defaultPrevented — проверяет можно ли вызвать метод preventDefault() для данного события;
//view — возвращает ссылку на объект window, в котором произошло событие.

//И третий аргумент — это объект или булево значение, которое интерпретируется как
//{
//    useCapture: true // или false
//}

//useCapture — это фаза, на которой должен сработать обработчик.
//События могут срабатывать для любой части документа вследствие взаимодействия с ним пользователя или браузера.
//Они не просто начинаются и заканчиваются в одном месте; они циркулируют по всему документу, проходя свой собственный жизненный цикл.


//!!Фазы!!
//всплытие (bubbling) и погружение (capturing)

//Событие движется от корня документа к цели (фаза перехвата — Capturing),
//затем срабатывает для цели события(фаза цели — Target)
//и движется назад к корню документа(фаза всплытия — Bubbling).

//По умолчанию, useCapture в addEventListener — это false, поэтому события будут всплывать.

//Почти все события всплывают! Исключением, например, является событие focus.

//Чаще всего, всплытие событий мешает. Чтобы предотвратить это, используют следующие функции:
event.stopPropagation() //События, которые идут за тем, в котором вызвана эта функция, на текущем элементе, отработают, всплытие остановится.
event.stopImmediatePropagation() //Все события, идущие за тем, которое вызывает эту функцию, не сработают, всплытие остановится.
event.preventDefault() //Он останавливает действия браузера по умолчанию (типа открытие ссылки). Аналогично, можно из обработчика, заданного через on<event> вернуть false.

//!!Удаление обработчика!!
element.removeEventListener(event, handler, [phase]);
//Это может быть полезно, когда вы точно знаете, что событие больше не должно выполняться или существует условие для его отмены.

//<button onclick="click()" id="btn">Press</button>

//<script>
//  function click1() {
//    alert('Click1');
//  };

//  btn.addEventListener("click", click1); // Click1
//  btn.removeEventListener("click", click1); //
//</script>



//_____________________________________________________________________
//Формы

//<form>
//    <!-- элементы формы -->
//</form>

//Элементы формы — это различные типы полей для ввода информации, такие как текстовые поля, чекбоксы, радио-кнопки и так далее.

//<form>
//    <input type="text" name="form_input">
//    <input type="radio" name="form_input">
//    <button name="form_input"/>
//</form>

//Семантическая верстка подразумевает использование специальных HTML - элементов с определенной ролью:
//вместо < input type = "button" > — <button>,
//вместо <div class="navigation"> — <nav> и так далее.


//Чтобы связать элементы формы, можно использовать тег label.
//Он устанавливает связь между определенной меткой, в качестве которой обычно выступает текст, и элементом формы(<input>, <select>, <textarea>).
//Такая связь необходима, чтобы изменять значения элементов формы при нажатии курсором мыши на текст.
//Кроме того, с помощью < label > можно устанавливать горячие клавиши на клавиатуре и переходить на активный элемент подобно ссылкам.

//<body>
//  <form action="https://yandex.ru/search/" target="_blank"> - action это событие куда отпарвлять форму, target - открывает в новом окне
//    <label for="search">Поиск в Яндекс:</label><br> - label связан с input через id
//    <input type="search" id="search" name="text" placeholder="Введите поисковый запрос"><br> - должен быть указан name
//    <button type="submit">Искать</button> - отправляет сразу всю форму
//  </form>
//</body>


//В form еще есть атрибут method. Он определяет, как будет отправлен запрос.

//method = "get" - Метод get передает данные на сервер через адресную строку браузера.
//При формировании запроса к серверу все переменные и их значения формируют последовательность вида:
//www.anysite.ru/form.php?var1=1&var2=2 - имена и значения переменных присоединяются к адресу сервера после знака ? и разделяются между собой знаком &

//method = "post" - Метод post применяется для пересылки данных больших объемов, а также конфиденциальной информации и паролей.
//Данные, отправляемые с помощью этого метода, не видны в заголовке URL, так как они содержатся в теле сообщения.



//Валидация
//Существует три вида валидаций:
//1. Мгновенная валидация возможна только в тех случаях, когда в процессе ввода понятно, что значение некорректное.
//2. По потере фокуса — когда пользователь убирает фокус с поля, которое заполняет(кликает по другому полю, например);
//3. По отправке формы — при клике на кнопку submit(или любое другое действие, отправляющее форму).

//Существует два разных способа проверки формы:
//1 Проверка на стороне клиента — при заполнении в браузере, прежде чем данные будут отправлены на сервер.
//Можно валидировать форму с помощью JavaScript либо использовать встроенную проверку — есть специальные функции проверки формы HTML5.

//2 Проверка на стороне сервера — возникает на сервере после отправки данных.
//Серверный код используется для проверки данных перед их сохранением в базе данных.
//Если данные не проходят проверку валидности, ответ отправляется обратно клиенту, чтобы сообщить пользователю, какие исправления должны быть сделаны.

//Стремитесь к использованию комбинированной проверки на стороне клиента и сервера

//required - для html поля
//pattern - для html поля pattern="Male|Female"
//type - для html поля type="email"

//:invalid - для css
