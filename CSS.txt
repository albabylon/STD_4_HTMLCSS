Абсолютное большинство современных сайтов использует CSS (каскадные таблицы стилей). 
Этот язык отвечает за визуальное оформление элементов, помогает настроить шрифты и цвета, расположить блоки.

Но для того чтобы таблицы стилей начали работать, их нужно подключить к разметке. Это можно сделать тремя способами:

1 Использовать глобальные стили CSS;
2 Использовать внутренний CSS для конкретного элемента страницы;
3 Подключать внешние файлы с расширением .css.

!!!Глобальные стили
Свойства CSS при использовании глобальных стилей описывают внутри тега <style>, который, в свою очередь, располагается внутри тега <head>.

Стили, подключённые таким образом, загружаются заново при каждой перезагрузке страницы. Это может повлиять на скорость взаимодействия пользователя с сервисом, 
поэтому в реальных и больших проектах к глобальным стилям прибегают очень редко. 
  <head>
    <meta charset="utf-8">
    <style>
      h1 {
        font-size: 22px; 
        color: red;
      }
	body {
        background-color: blue;
      }
    </style>
  </head>


!!!Внутренние стили
Внутренние стили используются для конкретного тега HTML, реализуются при помощи атрибута style.
<h1 style="font-size: 22px; color: red">Hello, world!</h1>
Этот способ, который иначе называется инлайн-стилями, удобен для проверки и предпросмотра изменений. 



!!!Внешние стили
Чаще всего внешние стили подключают из CSS-файла с помощью тега <link>. Все изменения в исходном файле будут отражаться на сайте.
  <head>
    <link href="style.css" rel="stylesheet" type="text/css">
    <link href="http://ourwebsite.ru/main.css" rel="stylesheet">
  </head>

В атрибуте href задаётся путь к CSS-файлу.

Атрибут rel (relation) указывает тип связи между документом и файлом.
rel="stylesheet" сообщает браузеру, что мы подключаем стили.
type="text/css" указывает тип внешнего файла.


Селектор определяет, какой элемент (или элементы) станет объектом определения стилей. 
Свойство селектора отвечает за выбор характеристики для изменений. 
И наконец, его значение помогает определить, как именно что-либо необходимо изменить. 
Вся эта запись называется правило CSS.

Запись правила CSS в общем виде выглядит так:
селектор {
свойство-1: значение-1;
свойство-2: значение-2;
}

h1 { 
color: red;
background: blue;
}


Простые селекторы
В свою очередь, простые селекторы делятся на:

А) Селектор по тегу позволяет выбрать на странице все элементы какого-либо типа, например, параграфы, заголовки, блоки и так далее.
h1 { 
color: red;
}

Б) Селектор по классу — самый распространённый вариант в современной вёрстке. 
Он позволяет разработчику самостоятельно выбрать элементы, к которым будет применён стиль

-задаем имя класса в html в атрибут class
-в css задаем через точку:
.food, .household и .vet. Точка перед названием — специальное обозначение, которое даёт CSS понять, что мы применяем стиль к классу.
-для применения нескольких стилей перечисляются через пробел:
<li class="food not-bought">Лук</li>
или
Обратите внимание: селекторы можно записывать последовательно, без пробела.
Например: 
.class1.class2 /* элемент с двумя классами class1 и class2 */
div#some-id.class1 /* div с идентификатором some-id и классом class1*/

В) Селектор по идентификатору определяет уникальное имя элемента, 
которое используется для изменения его стиля и обращения к нему через скрипты

-задаем id в html в атрибут id
<li id="Sofa">Переобивка дивана</li>  

-в css для записи селектора по идентификатору используется решётка.
#Sofa {
color: red:
}

!У идентификатора самый большой приоритет среди селекторов, то есть стили, назначенные при помощи селектора по идентификатору, очень сложно менять.

Г) Селектор по атрибуту позволяет обратиться к элементу HTML по значению его атрибутов, записывается при помощи квадратных скобок.
Целиком
Например, для того, чтобы изменить цвет фона ссылки на продукты, используем селектор a[href="#Food"].

Содержит
Селектор можно записать следующим образом a[href *= "ouse"] или a[href *= ouse], а фон сделаем зелёным. 
Оператор *= означает, что искомое может располагаться где угодно в значении атрибута

зная только окончание значения $=
или только его начало ^=



Простой комбинатор (запятая) выбирает все совпадающие узлы.

Синтаксис: селектор-1, селектор-2

Пример: div, p выберет оба элемента: и <div>, и <p>.



Комбинатор потомков (пробел) выбирает элементы, которые находятся внутри указанного элемента (вне зависимости от уровня вложенности).

Синтаксис: селектор-1 селектор-2 (через пробел)

Пример: div p выберет все элементы <p>, которые находятся внутри элемента <div>.



Комбинатор дочерних элементов (>), в отличие от пробела, выбирает только дочерние элементы.

Синтаксис: селектор-1 > селектор-2

Пример: div > img выберет только дочерние, первого уровня вложенности, элементы <img>.



Комбинатор соседних элементов (~) выбирает элементы, которые находятся на этом же уровне вложенности, после указанного элемента, с тем же родителем.

Синтаксис: селектор-1 ~ селектор-2

Пример: p ~ .cat выберет все элементы с классом cat, которые находятся после элемента <p> внутри одного родителя.



Комбинатор следующего соседнего элемента (+) выбирает элемент, который находится сразу после указанного элемента, внутри одного родителя.

Синтаксис: селектор-1 + селектор-2

Пример: .header + .container выберет элемент с классом container, который находится непосредственно после элемента с классом header.




!!!Псевдоклассы
Псевдоклассы определяют специальные состояния элементов. Они обязательно относятся к какому-либо селектору, записываются через двоеточие.
a:visited {
color: red;
}


:hover (наведение на объект, чаще всего кнопку или ссылку).
:visited (посещённая ранее ссылка).
:focus (элемент с фокусом на нём, например, элемент формы).
:first-child и :last-child (первый и последний подобный встречающийся элемент, например, li:first-child первый элемент списка).
    :nth-child(число) (касается конкретного элемента, например, li:nth-child(2) — второй элемент <li>).
    :nth-child(odd) (все нечётные элементы).
    :nth-child(even) (все чётные элементы).
:first-of-type и :nth-of-type (первый и n-ный элемент какого-либо типа).
:disabled (недоступный элемент, например, button:disabled — кнопка, на которую невозможно нажать).



!!!Псевдоэлементы
Наравне с псевдоклассами, псевдоэлементы используются для того, чтобы сделать страницу более удобной для пользователя. 
Они стилизуют часть выбранного элемента. Записываются после двух двоеточий без пробела.

 ::first-line может изменить стиль первой строки. Например, абзаца. 

::before добавляет что-то перед началом элемента. Например, в примере со списком покупок, 
если бы появились какие-то новые пункты, мы могли бы создать для них специальный класс (в HTML: class="newads"), 
а потом поставить для обозначения какой-то символ, используя  .newads::before.

::after добавляет что-то после окончания элемента.



!!!Приоритет селекторов

Селектор тега весит 1 балл.
Селектор класса, селектор по атрибуту или селектор псевдокласса — 10 баллов.
Селектор по идентификатору — 100 баллов.
Внутренний стиль (стиль, заданный при помощи атрибута style в коде HTML) — 1000 баллов.


Обратите внимание 
Специфичность имеет значение только в том случае, если один элемент подходит сразу нескольким селекторам. 
Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS.
Правило для конкретного элемента всегда будет иметь больший приоритет, чем правила, унаследованные от его предка.

Модификатор !important
Запрещённый, но при этом вполне работающий приём при определении стилей — применение модификатора !important.
Этот модификатор позволяет «перебить» стили, несмотря на вес селекторов.

И в стиле с наименьшим весом селекторов определить правило !important:
li {
  font-size: 14px  !important;
}


best practices:
1 Используйте преимущественно селекторы классов. Даже если речь идёт о заголовке или другом уникальном элементе.
2 Не применяйте к одному элементу чрезмерное количество классов.
3 Избегайте встроенных стилей, таких как <a style="color: red;">.
4 Не рассчитывайте на модификатор !important. Лучше, если вы просто будете знать о его существовании, но не более.