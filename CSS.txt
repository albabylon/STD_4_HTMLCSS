Абсолютное большинство современных сайтов использует CSS (каскадные таблицы стилей). 
Этот язык отвечает за визуальное оформление элементов, помогает настроить шрифты и цвета, расположить блоки.

Но для того чтобы таблицы стилей начали работать, их нужно подключить к разметке. Это можно сделать тремя способами:

1 Использовать глобальные стили CSS;
2 Использовать внутренний CSS для конкретного элемента страницы;
3 Подключать внешние файлы с расширением .css.

!!!Глобальные стили
Свойства CSS при использовании глобальных стилей описывают внутри тега <style>, который, в свою очередь, располагается внутри тега <head>.

Стили, подключённые таким образом, загружаются заново при каждой перезагрузке страницы. Это может повлиять на скорость взаимодействия пользователя с сервисом, 
поэтому в реальных и больших проектах к глобальным стилям прибегают очень редко. 
  <head>
    <meta charset="utf-8">
    <style>
      h1 {
        font-size: 22px; 
        color: red;
      }
	body {
        background-color: blue;
      }
    </style>
  </head>


!!!Внутренние стили
Внутренние стили используются для конкретного тега HTML, реализуются при помощи атрибута style.
<h1 style="font-size: 22px; color: red">Hello, world!</h1>
Этот способ, который иначе называется инлайн-стилями, удобен для проверки и предпросмотра изменений. 



!!!Внешние стили
Чаще всего внешние стили подключают из CSS-файла с помощью тега <link>. Все изменения в исходном файле будут отражаться на сайте.
  <head>
    <link href="style.css" rel="stylesheet" type="text/css">
    <link href="http://ourwebsite.ru/main.css" rel="stylesheet">
  </head>

В атрибуте href задаётся путь к CSS-файлу.

Атрибут rel (relation) указывает тип связи между документом и файлом.
rel="stylesheet" сообщает браузеру, что мы подключаем стили.
type="text/css" указывает тип внешнего файла.


Селектор определяет, какой элемент (или элементы) станет объектом определения стилей. 
Свойство селектора отвечает за выбор характеристики для изменений. 
И наконец, его значение помогает определить, как именно что-либо необходимо изменить. 
Вся эта запись называется правило CSS.

Запись правила CSS в общем виде выглядит так:
селектор {
свойство-1: значение-1;
свойство-2: значение-2;
}

h1 { 
color: red;
background: blue;
}


Простые селекторы
В свою очередь, простые селекторы делятся на:

А) Селектор по тегу позволяет выбрать на странице все элементы какого-либо типа, например, параграфы, заголовки, блоки и так далее.
h1 { 
color: red;
}

Б) Селектор по классу — самый распространённый вариант в современной вёрстке. 
Он позволяет разработчику самостоятельно выбрать элементы, к которым будет применён стиль

-задаем имя класса в html в атрибут class
-в css задаем через точку:
.food, .household и .vet. Точка перед названием — специальное обозначение, которое даёт CSS понять, что мы применяем стиль к классу.
-для применения нескольких стилей перечисляются через пробел:
<li class="food not-bought">Лук</li>
или
Обратите внимание: селекторы можно записывать последовательно, без пробела.
Например: 
.class1.class2 /* элемент с двумя классами class1 и class2 */
div#some-id.class1 /* div с идентификатором some-id и классом class1*/

В) Селектор по идентификатору определяет уникальное имя элемента, 
которое используется для изменения его стиля и обращения к нему через скрипты

-задаем id в html в атрибут id
<li id="Sofa">Переобивка дивана</li>  

-в css для записи селектора по идентификатору используется решётка.
#Sofa {
color: red:
}

!У идентификатора самый большой приоритет среди селекторов, то есть стили, назначенные при помощи селектора по идентификатору, очень сложно менять.

Г) Селектор по атрибуту позволяет обратиться к элементу HTML по значению его атрибутов, записывается при помощи квадратных скобок.
Целиком
Например, для того, чтобы изменить цвет фона ссылки на продукты, используем селектор a[href="#Food"].

Содержит
Селектор можно записать следующим образом a[href *= "ouse"] или a[href *= ouse], а фон сделаем зелёным. 
Оператор *= означает, что искомое может располагаться где угодно в значении атрибута

зная только окончание значения $=
или только его начало ^=



Простой комбинатор (запятая) выбирает все совпадающие узлы.

Синтаксис: селектор-1, селектор-2

Пример: div, p выберет оба элемента: и <div>, и <p>.



Комбинатор потомков (пробел) выбирает элементы, которые находятся внутри указанного элемента (вне зависимости от уровня вложенности).

Синтаксис: селектор-1 селектор-2 (через пробел)

Пример: div p выберет все элементы <p>, которые находятся внутри элемента <div>.



Комбинатор дочерних элементов (>), в отличие от пробела, выбирает только дочерние элементы.

Синтаксис: селектор-1 > селектор-2

Пример: div > img выберет только дочерние, первого уровня вложенности, элементы <img>.



Комбинатор соседних элементов (~) выбирает элементы, которые находятся на этом же уровне вложенности, после указанного элемента, с тем же родителем.

Синтаксис: селектор-1 ~ селектор-2

Пример: p ~ .cat выберет все элементы с классом cat, которые находятся после элемента <p> внутри одного родителя.



Комбинатор следующего соседнего элемента (+) выбирает элемент, который находится сразу после указанного элемента, внутри одного родителя.

Синтаксис: селектор-1 + селектор-2

Пример: .header + .container выберет элемент с классом container, который находится непосредственно после элемента с классом header.




!!!Псевдоклассы
Псевдоклассы определяют специальные состояния элементов. Они обязательно относятся к какому-либо селектору, записываются через двоеточие.
a:visited {
color: red;
}


:hover (наведение на объект, чаще всего кнопку или ссылку).
:visited (посещённая ранее ссылка).
:focus (элемент с фокусом на нём, например, элемент формы).
:first-child и :last-child (первый и последний подобный встречающийся элемент, например, li:first-child первый элемент списка).
    :nth-child(число) (касается конкретного элемента, например, li:nth-child(2) — второй элемент <li>).
    :nth-child(odd) (все нечётные элементы).
    :nth-child(even) (все чётные элементы).
:first-of-type и :nth-of-type (первый и n-ный элемент какого-либо типа).
:disabled (недоступный элемент, например, button:disabled — кнопка, на которую невозможно нажать).



!!!Псевдоэлементы
Наравне с псевдоклассами, псевдоэлементы используются для того, чтобы сделать страницу более удобной для пользователя. 
Они стилизуют часть выбранного элемента. Записываются после двух двоеточий без пробела.

 ::first-line может изменить стиль первой строки. Например, абзаца. 

::before добавляет что-то перед началом элемента. Например, в примере со списком покупок, 
если бы появились какие-то новые пункты, мы могли бы создать для них специальный класс (в HTML: class="newads"), 
а потом поставить для обозначения какой-то символ, используя  .newads::before.

::after добавляет что-то после окончания элемента.



!!!Приоритет селекторов

Селектор тега весит 1 балл.
Селектор класса, селектор по атрибуту или селектор псевдокласса — 10 баллов.
Селектор по идентификатору — 100 баллов.
Внутренний стиль (стиль, заданный при помощи атрибута style в коде HTML) — 1000 баллов.


Обратите внимание 
Специфичность имеет значение только в том случае, если один элемент подходит сразу нескольким селекторам. 
Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS.
Правило для конкретного элемента всегда будет иметь больший приоритет, чем правила, унаследованные от его предка.

Модификатор !important
Запрещённый, но при этом вполне работающий приём при определении стилей — применение модификатора !important.
Этот модификатор позволяет «перебить» стили, несмотря на вес селекторов.

И в стиле с наименьшим весом селекторов определить правило !important:
li {
  font-size: 14px  !important;
}


best practices:
1 Используйте преимущественно селекторы классов. Даже если речь идёт о заголовке или другом уникальном элементе.
2 Не применяйте к одному элементу чрезмерное количество классов.
3 Избегайте встроенных стилей, таких как <a style="color: red;">.
4 Не рассчитывайте на модификатор !important. Лучше, если вы просто будете знать о его существовании, но не более.



!!!Цвета

HTML распознаёт только 16 основных цветовых ключевых слов из CSS1, а остальные браузер пытается интерпретировать, используя определённый алгоритм.

Стоит также иметь в виду, что, в отличие от HTML, CSS полностью игнорирует неизвестные ключевые слова. Кроме того, количество готовых цветов ограничено.

!!Цвета в шестнадцатеричном представлении
Классический способ задавать RGB-цвета, который используется не только в веб-разработке, но и во многих графических редакторах, 
шестнадцатеричное представление. На каждый из основных цветов и альфа-канал(прозрачность) в таком представлении выделяется по два символа 
в шестнадцатеричном алфавите [0-9, A-F].

.one {
  background-color: #FF0000;
}

с альфа-каналом(прозрачность)
.one {
  background-color: #FF0000FF;
}

сокращенный вариант (при совпадении вторых символов)
.one {
  background-color: #F00;
}


!!Функциональная запись цветов
Другая часто встречающаяся форма записи цветов — функциональная. 
В ней каждый цвет разложен по интенсивности тех же основных цветов: красного, зелёного и синего. 
Параметры записываются через запятую и изменяются от 0 до 255.

.one {
  background-color: rgb(255, 0, 0);
}

с альфа-каналом(прозрачность)
.one {
  background-color: rgb(255, 0, 0, 1);
}


!!Запись цветов в системах HSL и HSLA
Если по работе вы планируете часто общаться с дизайнерами, то имеет смысл получить представление о системе цветового круга, 
которую они часто используют для подбора контрастов, пар цветов и оттенков.

Контраст позволит выбрать два цвета для оформления, 
триада и тетрада — три и четыре, соответственно, 
аналогия нужна для поиска комплементарного оттенка, 
акцент-аналогия позволит выбрать и комплементарные оттенки, и контрастный цвет.

HSL — описывает цвета, как раз исходя из положения цвета на цветовом круге.
color: hsl(285, 100%, 60%);

Первый параметр — оттенок, который выражен в градусах от 0 до 360, определяющих позицию цвета на цветовом круге.
Второй параметр — насыщенность, задаётся в процентах от 0% до 100%.
Третий параметр — светлота, который также задаётся в процентах и указывает, насколько светлым или тёмным будет тон цвета.

В современных браузерах rgba() и rgb(), так же как hsl() и hsla(), являются идентичными функциями с различным написанием

!!Свойства CSS, связанные с цветами

Свойство color задаёт цвет элементу
Свойство background-color задаёт фон элемента
Свойство border-color задаёт цвет границы (но перед тем, как задавать цвет, нужно определиться с её толщиной и дополнительными свойствами)
Свойство background-image задаёт фоновую картинку



!!!Размеры в CSS

!!Единицы измерения
Абсолютные единицы измерения обозначают физический размер — дюймы, сантиметры, миллиметры, пункты, пики, а также пиксели.
Сейчас в основном используются размеры в пикселях (px)

Изначально предполагалось, что пиксель — это самая маленькая часть экрана, один светодиод.

Большинство относительных единиц измерения используются для определения размеров шрифта
em	Размер шрифта текущего элемента
ex	Высота символа x
ch	Ширина символа 0 текущего элемента
rem	Размер шрифта корневого элемента


Единица em — это изменяемое значение, которое зависит от размера шрифта текущего элемента 
(размер устанавливается через стилевое свойство font-size). Поэтому изначально 1em равен размеру шрифта, 
заданному в браузере по умолчанию, или размеру шрифта родительского элемента. Процентная запись идентична em. 
В том смысле, что значения 1em и 100% равны.

Единица ex определяется как высота символа «x» в нижнем регистре. 
На ex распространяются те же правила, что и на em: он привязан к размеру шрифта, 
заданному в браузере по умолчанию, или к размеру шрифта родительского элемента.

Единица ch равна ширине символа «0» для текущего элемента.

Разница между em и rem следующая: em зависит от размера шрифта родителя элемента и меняется вместе с ним, 
а rem привязан к корневому элементу, то есть к размеру шрифта для элемента HTML.


Существует также группа относительных единиц измерения, зависящая от области просмотра браузера (viewport):
vw	1% от ширины viewport
vh	1% от высоты viewport
vmin	1% от меньшего измерения viewport
vmax	1% от большего измерения viewport


!!Базовые свойства, связанные с размерами
width — ширина. Если раньше задать размер ширины любого блочного элемента в пикселях было нормой, 
то теперь при вёрстке часто нужно прибегать к свойствам, позволяющим адаптировать размер:
min-width — минимально возможная ширина элемента,
max-width — максимально возможная ширина элемента.

height — высота. Свойства, позволяющие адаптировать высоту:
min-height — минимально возможная высота элемента,
max-height — максимально возможная высота элемента.

font-size — размер шрифта. 